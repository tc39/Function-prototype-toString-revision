<!doctype html>
<meta charset="utf8">
<link rel="shortcut icon" href="https://tc39.github.io/ecma262/img/favicon.ico" />
<pre class=metadata>
title: Function.prototype.toString revision
status: proposal
stage: 4
contributors: Michael Ficarra
location: https://github.com/tc39/Function-prototype-toString-revision
</pre>


<emu-intro id="sec-introduction">
  <h1>Introduction</h1>
  <h2>Goals</h2>

  <p>The original goals of this proposal were</p>

  <ul>
    <li>
      remove the forward-incompatible requirement
      <blockquote>
        If the implementation cannot produce a source code string that meets these criteria then it must return a string for which `eval` will throw a *SyntaxError* exception.
      </blockquote>
    <li>clarify the "functionally equivalent" requirement
    <li>standardise the string representation of built-in functions and host objects
    <li>clarify requirement of representation based on the "actual characteristics" of an object
  </ul>

  <p>The goals were later revised to include</p>

  <ul>
    <li>ensure that the string's parse contains the same function body and parameter list as the original
  </ul>

  <p>The goals were revised again to include</p>

  <ul>
    <li>for functions defined using ECMAScript code, `toString` must return source text slice from beginning of first token to end of last token matched by the appropriate grammar production
    <li>for built-in function objects and bound function exotic objects, `toString` must not return anything other than |NativeFunction|
    <li>for callable objects which were not defined using ECMAScript code, `toString` must return |NativeFunction|
    <li>for functions created dynamically (through the *Function* and *GeneratorFunction* constructors), `toString` must synthesise a source text
    <li>for all other objects, `toString` must throw a *TypeError* exception
  </ul>

  <p>The goals were revised yet again to include</p>

  <ul>
    <li>implementations must not be required to retain source text for all functions defined using ECMAScript code
  </ul>
</emu-intro>


<!-- es6num="5.2" -->
<emu-clause id="proposal-sec-algorithm-conventions">
  <h1>(<emu-xref href="#sec-algorithm-conventions">5.2</emu-xref>) Algorithm Conventions</h1>
  <p>The specification often uses a numbered list to specify steps in an algorithm. These algorithms are used to precisely specify the required semantics of ECMAScript language constructs. The algorithms are not intended to imply the use of any specific implementation technique. In practice, there may be more efficient algorithms available to implement a given feature.</p>
  <p>Algorithms may be explicitly parameterized, in which case the names and usage of the parameters must be provided as part of the algorithm's definition. In order to facilitate their use in multiple parts of this specification, some algorithms, called <em>abstract operations</em>, are named and written in parameterized functional form so that they may be referenced by name from within other algorithms. Abstract operations are typically referenced using a functional application style such as operationName(_arg1_, _arg2_). Some abstract operations are treated as polymorphically dispatched methods of class-like specification abstractions. Such method-like abstract operations are typically referenced using a method application style such as _someValue_.operationName(_arg1_, _arg2_).</p>
  <p>Calls to abstract operations return Completion Records. Abstract operations referenced using the functional application style and the method application style that are prefixed by `?` indicate that ReturnIfAbrupt should be applied to the resulting Completion Record. For example, ? operationName() is equivalent to ReturnIfAbrupt(operationName()). Similarly, ? _someValue_.operationName() is equivalent to ReturnIfAbrupt(_someValue_.operationName()).</p>
  <p>The prefix `!` is used to indicate that an abstract operation will never return an abrupt completion and that the resulting Completion Record's value field should be used in place of the return value of the operation. For example, &ldquo;Let _val_ be ! operationName()&rdquo; is equivalent to the following algorithm steps:</p>
  <emu-alg>
    1. Let _val_ be operationName().
    1. Assert: _val_ is never an abrupt completion.
    1. If _val_ is a Completion Record, let _val_ be _val_.[[Value]].
  </emu-alg>
  <p>Algorithms may be associated with productions of one of the ECMAScript grammars. A production that has multiple alternative definitions will typically have a distinct algorithm for each alternative. When an algorithm is associated with a grammar production, it may reference the terminal and nonterminal symbols of the production alternative as if they were parameters of the algorithm. When used in this manner, nonterminal symbols refer to the actual alternative definition that is matched when parsing the source text. <ins> The <dfn>source text matched by</dfn> a grammar production is the portion of the source text that starts at the beginning of the first terminal that participated in the match and ends at the end of the last terminal that participated in the match.</ins></p>
  <p>When an algorithm is associated with a production alternative, the alternative is typically shown without any &ldquo;[ ]&rdquo; grammar annotations. Such annotations should only affect the syntactic recognition of the alternative and have no effect on the associated semantics for the alternative.</p>
  <p>Unless explicitly specified otherwise, all chain productions have an implicit definition for every algorithm that might be applied to that production's left-hand side nonterminal. The implicit definition simply reapplies the same algorithm name with the same parameters, if any, to the chain production's sole right-hand side nonterminal and then returns the result. For example, assume there is a production:</p>
  <emu-grammar>
    Block :
      `{` StatementList `}`
  </emu-grammar>
  <p>but there is no corresponding Evaluation algorithm that is explicitly specified for that production. If in some algorithm there is a statement of the form: &ldquo;Return the result of evaluating |Block|&rdquo; it is implicit that an Evaluation algorithm exists of the form:</p>
  <p><b>Runtime Semantics: Evaluation</b></p>
  <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
  <emu-alg>
    1. Return the result of evaluating |StatementList|.
  </emu-alg>
  <p>For clarity of expression, algorithm steps may be subdivided into sequential substeps. Substeps are indented and may themselves be further divided into indented substeps. Outline numbering conventions are used to identify substeps with the first level of substeps labelled with lower case alphabetic characters and the second level of substeps labelled with lower case roman numerals. If more than three levels are required these rules repeat with the fourth level using numeric labels. For example:</p>
  <emu-alg>
    1. Top-level step
      1. Substep.
      1. Substep.
        1. Subsubstep.
          1. Subsubsubstep
            1. Subsubsubsubstep
              1. Subsubsubsubsubstep
  </emu-alg>
  <p>A step or substep may be written as an &ldquo;if&rdquo; predicate that conditions its substeps. In this case, the substeps are only applied if the predicate is true. If a step or substep begins with the word &ldquo;else&rdquo;, it is a predicate that is the negation of the preceding &ldquo;if&rdquo; predicate step at the same level.</p>
  <p>A step may specify the iterative application of its substeps.</p>
  <p>A step that begins with &ldquo;Assert:&rdquo; asserts an invariant condition of its algorithm. Such assertions are used to make explicit algorithmic invariants that would otherwise be implicit. Such assertions add no additional semantic requirements and hence need not be checked by an implementation. They are used simply to clarify algorithms.</p>
  <p>Mathematical operations such as addition, subtraction, negation, multiplication, division, and the mathematical functions defined later in this clause should always be understood as computing exact mathematical results on mathematical real numbers, which unless otherwise noted do not include infinities and do not include a negative zero that is distinguished from positive zero. Algorithms in this standard that model floating-point arithmetic include explicit steps, where necessary, to handle infinities and signed zero and to perform rounding. If a mathematical operation or function is applied to a floating-point number, it should be understood as being applied to the exact mathematical value represented by that floating-point number; such a floating-point number must be finite, and if it is *+0* or *-0* then the corresponding mathematical value is simply 0.</p>
  <p>The mathematical function <emu-eqn aoid="abs">abs(_x_)</emu-eqn> produces the absolute value of _x_, which is <emu-eqn>-_x_</emu-eqn> if _x_ is negative (less than zero) and otherwise is _x_ itself.</p>
  <p>The mathematical function <emu-eqn aoid="min">min(_x1_, _x2_, ..., _xN_)</emu-eqn> produces the mathematically smallest of <emu-eqn>_x1_</emu-eqn> through <emu-eqn>_xN_</emu-eqn>. The mathematical function <emu-eqn aoid="max">max(_x1_, _x2_, ..., _xN_)</emu-eqn> produces the mathematically largest of <emu-eqn>_x1_</emu-eqn> through <emu-eqn>_xN_</emu-eqn>. The domain and range of these mathematical functions include *+&infin;* and *-&infin;*.</p>
  <p>The notation &ldquo;<emu-eqn aoid="modulo">_x_ modulo _y_</emu-eqn>&rdquo; (_y_ must be finite and nonzero) computes a value _k_ of the same sign as _y_ (or zero) such that <emu-eqn>abs(_k_) &lt; abs(_y_) and _x_-_k_ = _q_ &times; _y_</emu-eqn> for some integer _q_.</p>
  <p>The mathematical function <emu-eqn aoid="floor">floor(_x_)</emu-eqn> produces the largest integer (closest to positive infinity) that is not larger than _x_.</p>
  <emu-note>
    <p><emu-eqn>floor(_x_) = _x_-(_x_ modulo 1)</emu-eqn>.</p>
  </emu-note>
</emu-clause>


<!-- 9.2 -->
<emu-clause id="proposal-sec-ecmascript-function-objects">
  <h1>(<emu-xref href="#sec-ecmascript-function-objects">9.2</emu-xref>) ECMAScript Function Objects</h1>
  <p>ECMAScript function objects encapsulate parameterized ECMAScript code closed over a lexical environment and support the dynamic evaluation of that code. An ECMAScript function object is an ordinary object and has the same internal slots and the same internal methods as other ordinary objects. The code of an ECMAScript function object may be either strict mode code (<emu-xref href="#sec-strict-mode-code"></emu-xref>) or non-strict mode code. An ECMAScript function object whose code is strict mode code is called a <em>strict function</em>. One whose code is not strict mode code is called a <em>non-strict function</em>.</p>
  <p>ECMAScript function objects have the additional internal slots listed in <emu-xref href="#table-27"></emu-xref>.</p>
  <emu-table id="table-27" caption="Internal Slots of ECMAScript Function Objects">
    <table>
      <tbody>
      <tr><th>Internal Slot</th><th>Type</th><th>Description</th></tr>
      <tr><td>[[Environment]]</td><td>Lexical Environment</td><td>The Lexical Environment that the function was closed over. Used as the outer environment when evaluating the code of the function.</td></tr>
      <tr><td>[[FormalParameters]]</td><td>Parse Node</td><td>The root parse node of the source text that defines the function's formal parameter list.</td></tr>
      <tr><td>[[FunctionKind]]</td><td>String</td><td>Either `"normal"`, `"classConstructor"` or `"generator"`.</td></tr>
      <tr><td>[[ECMAScriptCode]]</td><td>Parse Node</td><td>The root parse node of the source text that defines the function's body.</td></tr>
      <tr><td>[[ConstructorKind]]</td><td>String</td><td>Either `"base"` or `"derived"`.</td></tr>
      <tr><td>[[Realm]]</td><td>Realm Record</td><td>The realm in which the function was created and which provides any intrinsic objects that are accessed when evaluating the function.</td></tr>
      <tr><td>[[ScriptOrModule]]</td><td>Script Record or Module Record</td><td>The script or module in which the function was created.</td></tr>
      <tr><td>[[ThisMode]]</td><td>(lexical, strict, global)</td><td>Defines how `this` references are interpreted within the formal parameters and code body of the function. ~lexical~ means that `this` refers to the *this* value of a lexically enclosing function. ~strict~ means that the *this* value is used exactly as provided by an invocation of the function. ~global~ means that a *this* value of *undefined* is interpreted as a reference to the global object.</td></tr>
      <tr><td>[[Strict]]</td><td>Boolean</td><td>*true* if this is a strict mode function, *false* if this is not a strict mode function.</td></tr>
      <tr><td>[[HomeObject]]</td><td>Object</td><td>If the function uses `super`, this is the object whose [[GetPrototypeOf]] provides the object where `super` property lookups begin.</td></tr>
      <tr class="ins">
        <td><ins>[[SourceText]]</ins></td>
        <td><ins>String</ins></td>
        <td><ins>The <emu-xref href="#sec-source-text">source text</emu-xref> that defines the function.</ins></td>
      </tr>
      </tbody>
    </table>
  </emu-table>
  <p>All ECMAScript function objects have the [[Call]] internal method defined here. ECMAScript functions that are also constructors in addition have the [[Construct]] internal method.</p>
</emu-clause>


<!-- 14.1.19 -->
<emu-clause id="proposal-sec-function-definitions-runtime-semantics-instantiatefunctionobject">
  <h1>(<emu-xref href="#sec-function-definitions-runtime-semantics-instantiatefunctionobject">14.1.19</emu-xref>) Runtime Semantics: InstantiateFunctionObject</h1>
  <p>With parameter _scope_.</p>
  <emu-see-also-para op="InstantiateFunctionObject"></emu-see-also-para>
  <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for |FunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Let _F_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _scope_, _strict_).
    1. Perform MakeConstructor(_F_).
    1. Perform SetFunctionName(_F_, _name_).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |FunctionDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for |FunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _F_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _scope_, _strict_).
    1. Perform MakeConstructor(_F_).
    1. Perform SetFunctionName(_F_, `"default"`).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |FunctionDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-note>
    <p>An anonymous |FunctionDeclaration| can only occur as part of an `export default` declaration.</p>
  </emu-note>
</emu-clause>


<!-- 14.1.20 -->
<emu-clause id="proposal-sec-function-definitions-runtime-semantics-evaluation">
  <h1>(<emu-xref href="#sec-function-definitions-runtime-semantics-evaluation">14.1.20</emu-xref>) Runtime Semantics: Evaluation</h1>
  <emu-grammar>FunctionDeclaration : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. Return NormalCompletion(~empty~).
  </emu-alg>
  <emu-note>
    <p>An alternative semantics is provided in <emu-xref href="#sec-block-level-function-declarations-web-legacy-compatibility-semantics"></emu-xref>.</p>
  </emu-note>
  <emu-grammar>FunctionDeclaration : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. Return NormalCompletion(~empty~).
  </emu-alg>
  <emu-grammar>FunctionExpression : `function` `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for |FunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _closure_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _scope_, _strict_).
    1. Perform MakeConstructor(_closure_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |FunctionExpression|.</ins>
    1. Return _closure_.
  </emu-alg>
  <emu-grammar>FunctionExpression : `function` BindingIdentifier `(` FormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for |FunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).
    1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Perform _envRec_.CreateImmutableBinding(_name_, *false*).
    1. Let _closure_ be FunctionCreate(~Normal~, |FormalParameters|, |FunctionBody|, _funcEnv_, _strict_).
    1. Perform MakeConstructor(_closure_).
    1. Perform SetFunctionName(_closure_, _name_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |FunctionExpression|.</ins>
    1. Perform _envRec_.InitializeBinding(_name_, _closure_).
    1. Return _closure_.
  </emu-alg>
  <emu-note>
    <p>The |BindingIdentifier| in a |FunctionExpression| can be referenced from inside the |FunctionExpression|'s |FunctionBody| to allow the function to call itself recursively. However, unlike in a |FunctionDeclaration|, the |BindingIdentifier| in a |FunctionExpression| cannot be referenced from and does not affect the scope enclosing the |FunctionExpression|.</p>
  </emu-note>
  <emu-note>
    <p>A `prototype` property is automatically created for every function defined using a |FunctionDeclaration| or |FunctionExpression|, to allow for the possibility that the function will be used as a constructor.</p>
  </emu-note>
  <emu-grammar>FunctionStatementList : [empty]</emu-grammar>
  <emu-alg>
    1. Return NormalCompletion(*undefined*).
  </emu-alg>
</emu-clause>


<!-- 14.2.16 -->
<emu-clause id="proposal-sec-arrow-function-definitions-runtime-semantics-evaluation">
  <h1>(<emu-xref href="#sec-arrow-function-definitions-runtime-semantics-evaluation">14.2.16</emu-xref>) Runtime Semantics: Evaluation</h1>
  <emu-grammar>ArrowFunction : ArrowParameters `=&gt;` ConciseBody</emu-grammar>
  <emu-alg>
    1. If the function code for this |ArrowFunction| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _parameters_ be CoveredFormalsList of |ArrowParameters|.
    1. Let _closure_ be FunctionCreate(~Arrow~, _parameters_, |ConciseBody|, _scope_, _strict_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |ArrowFunction|.</ins>
    1. Return _closure_.
  </emu-alg>
  <emu-note>
    <p>An |ArrowFunction| does not define local bindings for `arguments`, `super`, `this`, or `new.target`. Any reference to `arguments`, `super`, `this`, or `new.target` within an |ArrowFunction| must resolve to a binding in a lexically enclosing environment. Typically this will be the Function Environment of an immediately enclosing function. Even though an |ArrowFunction| may contain references to `super`, the function object created in step 4 is not made into a method by performing MakeMethod. An |ArrowFunction| that references `super` is always contained within a non-|ArrowFunction| and the necessary state to implement `super` is accessible via the _scope_ that is captured by the function object of the |ArrowFunction|.</p>
  </emu-note>
</emu-clause>


<!-- 14.3.8 -->
<emu-clause id="proposal-sec-runtime-semantics-definemethod">
  <h1>(<emu-xref href="#sec-runtime-semantics-definemethod">14.3.8</emu-xref>) Runtime Semantics: DefineMethod</h1>
  <p>With parameters _object_ and optional parameter _functionPrototype_.</p>
  <emu-grammar>MethodDefinition : PropertyName `(` StrictFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. Let _propKey_ be the result of evaluating |PropertyName|.
    1. ReturnIfAbrupt(_propKey_).
    1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. If _functionPrototype_ was passed as a parameter, let _kind_ be ~Normal~; otherwise let _kind_ be ~Method~.
    1. Let _closure_ be FunctionCreate(_kind_, |StrictFormalParameters|, |FunctionBody|, _scope_, _strict_). If _functionPrototype_ was passed as a parameter, then pass its value as the _prototype_ optional argument of FunctionCreate.
    1. Perform MakeMethod(_closure_, _object_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |MethodDefinition|.</ins>
    1. Return the Record{[[Key]]: _propKey_, [[Closure]]: _closure_}.
  </emu-alg>
</emu-clause>


<!-- 14.3.9 -->
<emu-clause id="proposal-sec-method-definitions-runtime-semantics-propertydefinitionevaluation">
  <h1>(<emu-xref href="#sec-method-definitions-runtime-semantics-propertydefinitionevaluation">14.3.9</emu-xref>) Runtime Semantics: PropertyDefinitionEvaluation</h1>
  <p>With parameters _object_ and _enumerable_.</p>
  <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
  <emu-grammar>MethodDefinition : PropertyName `(` StrictFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. Let _methodDef_ be DefineMethod of |MethodDefinition| with argument _object_.
    1. ReturnIfAbrupt(_methodDef_).
    1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).
    1. Let _desc_ be the PropertyDescriptor{[[Value]]: _methodDef_.[[Closure]], [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.
    1. Return ? DefinePropertyOrThrow(_object_, _methodDef_.[[Key]], _desc_).
  </emu-alg>
  <emu-grammar>MethodDefinition : GeneratorMethod</emu-grammar>
  <p>See <emu-xref href="#sec-generator-function-definitions"></emu-xref>.</p>
  <emu-grammar>MethodDefinition : `get` PropertyName `(` `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. Let _propKey_ be the result of evaluating |PropertyName|.
    1. ReturnIfAbrupt(_propKey_).
    1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _formalParameterList_ be the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.
    1. Let _closure_ be FunctionCreate(~Method~, _formalParameterList_, |FunctionBody|, _scope_, _strict_).
    1. Perform MakeMethod(_closure_, _object_).
    1. Perform SetFunctionName(_closure_, _propKey_, `"get"`).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |MethodDefinition|.</ins>
    1. Let _desc_ be the PropertyDescriptor{[[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.
    1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
  </emu-alg>
  <emu-grammar>MethodDefinition : `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`</emu-grammar>
  <emu-alg>
    1. Let _propKey_ be the result of evaluating |PropertyName|.
    1. ReturnIfAbrupt(_propKey_).
    1. If the function code for this |MethodDefinition| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _closure_ be FunctionCreate(~Method~, |PropertySetParameterList|, |FunctionBody|, _scope_, _strict_).
    1. Perform MakeMethod(_closure_, _object_).
    1. Perform SetFunctionName(_closure_, _propKey_, `"set"`).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |MethodDefinition|.</ins>
    1. Let _desc_ be the PropertyDescriptor{[[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.
    1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
  </emu-alg>
</emu-clause>


<!-- 14.4.12 -->
<emu-clause id="proposal-sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject">
  <h1>(<emu-xref href="#sec-generator-function-definitions-runtime-semantics-instantiatefunctionobject">14.4.12</emu-xref>) Runtime Semantics: InstantiateFunctionObject</h1>
  <p>With parameter _scope_.</p>
  <emu-see-also-para op="InstantiateFunctionObject"></emu-see-also-para>
  <emu-grammar>GeneratorDeclaration : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for |GeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Let _F_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _scope_, _strict_).
    1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
    1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform SetFunctionName(_F_, _name_).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |GeneratorDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-grammar>GeneratorDeclaration : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for |GeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _F_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _scope_, _strict_).
    1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
    1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform SetFunctionName(_F_, `"default"`).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |GeneratorDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-note>
    <p>An anonymous |GeneratorDeclaration| can only occur as part of an `export default` declaration.</p>
  </emu-note>
</emu-clause>


<!-- 14.4.13 -->
<emu-clause id="proposal-sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation">
  <h1>(<emu-xref href="#sec-generator-function-definitions-runtime-semantics-propertydefinitionevaluation">14.4.13</emu-xref>) Runtime Semantics: PropertyDefinitionEvaluation</h1>
  <p>With parameter _object_ and _enumerable_.</p>
  <emu-see-also-para op="PropertyDefinitionEvaluation"></emu-see-also-para>
  <emu-grammar>GeneratorMethod : `*` PropertyName `(` StrictFormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
  <emu-alg>
    1. Let _propKey_ be the result of evaluating |PropertyName|.
    1. ReturnIfAbrupt(_propKey_).
    1. If the function code for this |GeneratorMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _closure_ be GeneratorFunctionCreate(~Method~, |StrictFormalParameters|, |GeneratorBody|, _scope_, _strict_).
    1. Perform MakeMethod(_closure_, _object_).
    1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
    1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform SetFunctionName(_closure_, _propKey_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |GeneratorMethod|.</ins>
    1. Let _desc_ be the PropertyDescriptor{[[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.
    1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
  </emu-alg>
</emu-clause>


<!-- 14.4.14 -->
<emu-clause id="proposal-sec-generator-function-definitions-runtime-semantics-evaluation">
  <h1>(<emu-xref href="#sec-generator-function-definitions-runtime-semantics-evaluation">14.4.14</emu-xref>) Runtime Semantics: Evaluation</h1>
  <emu-grammar>GeneratorExpression : `function` `*` `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for this |GeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _closure_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _scope_, _strict_).
    1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
    1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |GeneratorExpression|.</ins>
    1. Return _closure_.
  </emu-alg>
  <emu-grammar>GeneratorExpression : `function` `*` BindingIdentifier `(` FormalParameters `)` `{` GeneratorBody `}`</emu-grammar>
  <emu-alg>
    1. If the function code for this |GeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _funcEnv_ be NewDeclarativeEnvironment(_scope_).
    1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Perform _envRec_.CreateImmutableBinding(_name_, *false*).
    1. Let _closure_ be GeneratorFunctionCreate(~Normal~, |FormalParameters|, |GeneratorBody|, _funcEnv_, _strict_).
    1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
    1. Perform DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform SetFunctionName(_closure_, _name_).
    1. Perform _envRec_.InitializeBinding(_name_, _closure_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |GeneratorExpression|.</ins>
    1. Return _closure_.
  </emu-alg>
  <emu-note>
    <p>The |BindingIdentifier| in a |GeneratorExpression| can be referenced from inside the |GeneratorExpression|'s |FunctionBody| to allow the generator code to call itself recursively. However, unlike in a |GeneratorDeclaration|, the |BindingIdentifier| in a |GeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |GeneratorExpression|.</p>
  </emu-note>
</emu-clause>


<!-- 14.5.11 -->
<emu-clause id="proposal-sec-asyncgenerator-definitions-instantiatefunctionobject">
  <h1>(<emu-xref href="#sec-asyncgenerator-definitions-instantiatefunctionobject">14.5.11</emu-xref>) Runtime Semantics: InstantiateFunctionObject</h1>
  <p>With parameter _scope_.</p>
  <emu-grammar>
    AsyncGeneratorDeclaration : `async` [no LineTerminator here] `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for |AsyncGeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Let _F_ be ! AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
    1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
    1. Perform ! DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform ! SetFunctionName(_F_, _name_).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |AsyncGeneratorDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>

  <emu-grammar>
    AsyncGeneratorDeclaration : `async` [no LineTerminator here] `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for |AsyncGeneratorDeclaration| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _F_ be AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
    1. Let _prototype_ be ObjectCreate(%AsyncGeneratorPrototype%).
    1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform SetFunctionName(_F_, `"default"`).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |AsyncGeneratorDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-note>
    <p>An anonymous |AsyncGeneratorDeclaration| can only occur as part of an `export default` declaration.</p>
  </emu-note>
</emu-clause>


<!-- 14.5.12 -->
<emu-clause id="proposal-sec-asyncgenerator-definitions-propertydefinitionevaluation">
  <h1>(<emu-xref href="#sec-asyncgenerator-definitions-propertydefinitionevaluation">14.5.12</emu-xref>) Runtime Semantics: PropertyDefinitionEvaluation</h1>
  <p>With parameter _object_ and _enumerable_.</p>
  <emu-grammar>
    AsyncGeneratorMethod : `async` [no LineTerminator here] `*` PropertyName `(` UniqueFormalParameters `)` `{` AsyncGeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. Let _propKey_ be the result of evaluating |PropertyName|.
    1. ReturnIfAbrupt(_propKey_).
    1. If the function code for this |AsyncGeneratorMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Method~, |UniqueFormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
    1. Perform ! MakeMethod(_closure_, _object_).
    1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
    1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform ! SetFunctionName(_closure_, _propKey_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |AsyncGeneratorMethod|.</ins>
    1. Let _desc_ be PropertyDescriptor{[[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.
    1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
  </emu-alg>
</emu-clause>


<!-- 14.5.13 -->
<emu-clause id="proposal-sec-asyncgenerator-definitions-evaluation">
  <h1>(<emu-xref href="#sec-asyncgenerator-definitions-evaluation">14.5.13</emu-xref>) Runtime Semantics: Evaluation</h1>

  <emu-grammar>
    AsyncGeneratorExpression : `async` [no LineTerminator here] `function` `*` `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for this |AsyncGeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _scope_, _strict_).
    1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
    1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |AsyncGeneratorExpression|.</ins>
    1. Return _closure_.
  </emu-alg>

  <emu-grammar>
    AsyncGeneratorExpression : `async` [no LineTerminator here] `function` `*` BindingIdentifier `(` FormalParameters `)` `{` AsyncGeneratorBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for this |AsyncGeneratorExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the running execution context's LexicalEnvironment.
    1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).
    1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Perform ! _envRec_.CreateImmutableBinding(_name_).
    1. Let _closure_ be ! AsyncGeneratorFunctionCreate(~Normal~, |FormalParameters|, |AsyncGeneratorBody|, _funcEnv_, _strict_).
    1. Let _prototype_ be ! ObjectCreate(%AsyncGeneratorPrototype%).
    1. Perform ! DefinePropertyOrThrow(_closure_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Perform ! SetFunctionName(_closure_, _name_).
    1. Perform ! _envRec_.InitializeBinding(_name_, _closure_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |AsyncGeneratorExpression|.</ins>
    1. Return _closure_.
  </emu-alg>
  <emu-note>
    <p>The |BindingIdentifier| in an |AsyncGeneratorExpression| can be referenced from inside the |AsyncGeneratorExpression|'s |AsyncGeneratorBody| to allow the generator code to call itself recursively. However, unlike in an |AsyncGeneratorDeclaration|, the |BindingIdentifier| in an |AsyncGeneratorExpression| cannot be referenced from and does not affect the scope enclosing the |AsyncGeneratorExpression|.</p>
  </emu-note>
</emu-clause>


<!-- 14.5.15 -->
<emu-clause id="proposal-sec-runtime-semantics-bindingclassdeclarationevaluation">
  <h1>(<emu-xref href="#sec-runtime-semantics-bindingclassdeclarationevaluation">14.5.15</emu-xref>) Runtime Semantics: BindingClassDeclarationEvaluation</h1>
  <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
  <emu-alg>
    1. Let _className_ be StringValue of |BindingIdentifier|.
    1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with argument _className_.
    1. ReturnIfAbrupt(_value_).
    1. Let _hasNameProperty_ be ? HasOwnProperty(_value_, `"name"`).
    1. If _hasNameProperty_ is *false*, perform SetFunctionName(_value_, _className_).
    1. <ins>Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.</ins>
    1. Let _env_ be the running execution context's LexicalEnvironment.
    1. Perform ? InitializeBoundName(_className_, _value_, _env_).
    1. Return _value_.
  </emu-alg>
  <emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar>
  <emu-alg>
    1. <del>Return</del><ins>Let _value_ be</ins> the result of ClassDefinitionEvaluation of |ClassTail| with argument *undefined*.
    1. <ins>Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.</ins>
    1. <ins>Return _value_.</ins>
  </emu-alg>
  <emu-note>
    <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and the setting of a name property and establishing its binding are handled as part of the evaluation action for that production. See <emu-xref href="#sec-exports-runtime-semantics-evaluation"></emu-xref>.</p>
  </emu-note>
</emu-clause>

<!-- 14.5.16 -->
<emu-clause id="proposal-sec-class-definitions-runtime-semantics-evaluation">
  <h1>(<emu-xref href="#sec-class-definitions-runtime-semantics-evaluation">14.5.16</emu-xref>) Runtime Semantics: Evaluation</h1>
  <emu-grammar>ClassDeclaration : `class` BindingIdentifier ClassTail</emu-grammar>
  <emu-alg>
    1. Let _status_ be the result of BindingClassDeclarationEvaluation of this |ClassDeclaration|.
    1. ReturnIfAbrupt(_status_).
    1. Return NormalCompletion(~empty~).
  </emu-alg>
  <emu-note>
    <p><emu-grammar>ClassDeclaration : `class` ClassTail</emu-grammar> only occurs as part of an |ExportDeclaration| and is never directly evaluated.</p>
  </emu-note>
  <emu-grammar>ClassExpression : `class` BindingIdentifier? ClassTail</emu-grammar>
  <emu-alg>
    1. If |BindingIdentifier_opt| is not present, let _className_ be *undefined*.
    1. Else, let _className_ be StringValue of |BindingIdentifier|.
    1. Let _value_ be the result of ClassDefinitionEvaluation of |ClassTail| with argument _className_.
    1. ReturnIfAbrupt(_value_).
    1. If _className_ is not *undefined*, then
      1. Let _hasNameProperty_ be ? HasOwnProperty(_value_, `"name"`).
      1. If _hasNameProperty_ is *false*, then
        1. Perform SetFunctionName(_value_, _className_).
    1. <ins>Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.</ins>
    1. Return NormalCompletion(_value_).
  </emu-alg>
  <emu-note>
    <p>If the class definition included a `name` static method then that method is not over-written with a `name` data property for the class name.</p>
  </emu-note>
</emu-clause>


<!-- 14.7.10 -->
<emu-clause id="proposal-sec-async-function-definitions-InstantiateFunctionObject">
  <h1>(<emu-xref href="sec-async-function-definitions-InstantiateFunctionObject">14.7.10</emu-xref>) Runtime Semantics: InstantiateFunctionObject</h1>
  <p>With parameter _scope_.</p>
  <emu-grammar>
    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for |AsyncFunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Let _F_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
    1. Perform ! SetFunctionName(_F_, _name_).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |AsyncFunctionDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-grammar>
    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for |AsyncFunctionDeclaration| is strict mode code, let _strict_ be *true*. Otherwise, let _strict_ be *false*.
    1. Let _F_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
    1. Perform ! SetFunctionName(_F_, `"default"`).
    1. <ins>Set _F_.[[SourceText]] to the source text matched by |AsyncFunctionDeclaration|.</ins>
    1. Return _F_.
  </emu-alg>
</emu-clause>


<!-- 14.7.12 -->
<emu-clause id="proposal-sec-async-function-definitions-PropertyDefinitionEvaluation">
  <h1>(<emu-xref href="sec-async-function-definitions-PropertyDefinitionEvaluation">14.7.12</emu-xref>) Runtime Semantics: PropertyDefinitionEvaluation</h1>
  <p>With parameters _object_ and _enumerable_.</p>
  <emu-grammar>
    AsyncMethod : `async` [no LineTerminator here] PropertyName `(` UniqueFormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Let _propKey_ be the result of evaluating |PropertyName|.
    1. ReturnIfAbrupt(_propKey_).
    1. If the function code for this |AsyncMethod| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _closure_ be ! AsyncFunctionCreate(~Method~, |UniqueFormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
    1. Perform ! MakeMethod(_closure_, _object_).
    1. Perform ! SetFunctionName(_closure_, _propKey_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |AsyncMethod|.</ins>
    1. Let _desc_ be the PropertyDescriptor{[[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true*}.
    1. Return ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).
  </emu-alg>
</emu-clause>


<!-- 14.7.13 -->
<emu-clause id="proposal-sec-async-function-definitions-runtime-semantics-evaluation">
  <h1>(<emu-xref href="sec-async-function-definitions-runtime-semantics-evaluation">14.7.13</emu-xref>) Runtime Semantics: Evaluation</h1>
  <emu-grammar>
    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return NormalCompletion(~empty~).
  </emu-alg>

  <emu-grammar>
    AsyncFunctionDeclaration : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. Return NormalCompletion(~empty~).
  </emu-alg>

  <emu-grammar>
    AsyncFunctionExpression : `async` [no LineTerminator here] `function` `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for |AsyncFunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _closure_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _scope_, _strict_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |AsyncFunctionExpression|.</ins>
    1. Return _closure_.
  </emu-alg>

  <emu-grammar>
    AsyncFunctionExpression : `async` [no LineTerminator here] `function` BindingIdentifier `(` FormalParameters `)` `{` AsyncFunctionBody `}`
  </emu-grammar>
  <emu-alg>
    1. If the function code for |AsyncFunctionExpression| is strict mode code, let _strict_ be *true*. Otherwise let _strict_ be *false*.
    1. Let _scope_ be the LexicalEnvironment of the running execution context.
    1. Let _funcEnv_ be ! NewDeclarativeEnvironment(_scope_).
    1. Let _envRec_ be _funcEnv_'s EnvironmentRecord.
    1. Let _name_ be StringValue of |BindingIdentifier|.
    1. Perform ! _envRec_.CreateImmutableBinding(_name_).
    1. Let _closure_ be ! AsyncFunctionCreate(~Normal~, |FormalParameters|, |AsyncFunctionBody|, _funcEnv_, _strict_).
    1. Perform ! SetFunctionName(_closure_, _name_).
    1. Perform ! _envRec_.InitializeBinding(_name_, _closure_).
    1. <ins>Set _closure_.[[SourceText]] to the source text matched by |AsyncFunctionExpression|.</ins>
    1. Return _closure_.
  </emu-alg>

  <emu-grammar>
    AwaitExpression : `await` UnaryExpression
  </emu-grammar>
  <emu-alg>
    1. Let _exprRef_ be the result of evaluating |UnaryExpression|.
    1. Let _value_ be ? GetValue(_exprRef_).
    1. Return ? Await(_value_).
  </emu-alg>
</emu-clause>


<!-- es6num="19.2.1.1.1" -->
<emu-clause id="proposal-sec-createdynamicfunction" aoid="CreateDynamicFunction">
  <h1>(<emu-xref href="#sec-createdynamicfunction">19.2.1.1.1</emu-xref>) Runtime Semantics: CreateDynamicFunction( _constructor_, _newTarget_, _kind_, _args_ )</h1>
  <p>The abstract operation CreateDynamicFunction is called with arguments _constructor_, _newTarget_, _kind_, and _args_. _constructor_ is the constructor function that is performing this action, _newTarget_ is the constructor that `new` was initially applied to, _kind_ is either `"normal"`, `"generator"`, or `"async"`, and _args_ is a List containing the actual argument values that were passed to _constructor_. The following steps are taken:</p>
  <emu-alg>
    1. Assert: The execution context stack has at least two elements.
    1. Let _callerContext_ be the second to top element of the execution context stack.
    1. Let _callerRealm_ be _callerContext_'s Realm.
    1. Let _calleeRealm_ be the current Realm Record.
    1. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).
    1. If _newTarget_ is *undefined*, let _newTarget_ be _constructor_.
    1. If _kind_ is `"normal"`, then
      1. Let _goal_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.
      1. Let _fallbackProto_ be `"%FunctionPrototype%"`.
    1. Else if _kind_ is `"generator"`, then
      1. Let _goal_ be the grammar symbol |GeneratorBody|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.
      1. Let _fallbackProto_ be `"%Generator%"`.
    1. Else,
      1. Assert: _kind_ is `"async"`.
      1. Let _goal_ be the grammar symbol |AsyncFunctionBody|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, +Await]|.
      1. Let _fallbackProto_ be `"%AsyncFunctionPrototype%"`.
    1. Let _argCount_ be the number of elements in _args_.
    1. Let _P_ be the empty String.
    1. If _argCount_ = 0, let _bodyText_ be the empty String.
    1. Else if _argCount_ = 1, let _bodyText_ be _args_[0].
    1. Else _argCount_ &gt; 1,
      1. Let _firstArg_ be _args_[0].
      1. Let _P_ be ? ToString(_firstArg_).
      1. Let _k_ be 1.
      1. Repeat, while _k_ &lt; _argCount_-1
        1. Let _nextArg_ be _args_[_k_].
        1. Let _nextArgString_ be ? ToString(_nextArg_).
        1. Let _P_ be the result of concatenating the previous value of _P_, the String `","` (a comma), and _nextArgString_.
        1. Increase _k_ by 1.
      1. Let _bodyText_ be _args_[_k_].
    1. Let _bodyText_ be ? ToString(_bodyText_).
    1. Let _parameters_ be the result of parsing _P_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, using _parameterGoal_ as the goal symbol. Throw a *SyntaxError* exception if the parse fails.
    1. Let _body_ be the result of parsing _bodyText_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, using _goal_ as the goal symbol. Throw a *SyntaxError* exception if the parse fails.
    1. If _bodyText_ is strict mode code, then let _strict_ be *true*, else let _strict_ be *false*.
    1. If any static semantics errors are detected for _parameters_ or _body_, throw a *SyntaxError* or a *ReferenceError* exception, depending on the type of the error. If _strict_ is *true*, the Early Error rules for <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar> are applied. Parsing and early error detection may be interweaved in an implementation dependent manner.
    1. If ContainsUseStrict of _body_ is *true* and IsSimpleParameterList of _parameters_ is *false*, throw a *SyntaxError* exception.
    1. If any element of the BoundNames of _parameters_ also occurs in the LexicallyDeclaredNames of _body_, throw a *SyntaxError* exception.
    1. If _body_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
    1. If _parameters_ Contains |SuperCall| is *true*, throw a *SyntaxError* exception.
    1. If _body_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
    1. If _parameters_ Contains |SuperProperty| is *true*, throw a *SyntaxError* exception.
    1. If _kind_ is `"generator"`, then
      1. If _parameters_ Contains |YieldExpression| is *true*, throw a *SyntaxError* exception.
    1. If _kind_ is `"async"`, then
      1. If _parameters_ Contains |AwaitExpression| is *true*, throw a *SyntaxError* exception.
    1. If _strict_ is *true*, then
      1. If BoundNames of _parameters_ contains any duplicate elements, throw a *SyntaxError* exception.
    1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).
    1. Let _F_ be FunctionAllocate(_proto_, _strict_, _kind_).
    1. Let _realmF_ be _F_.[[Realm]].
    1. Let _scope_ be _realmF_.[[GlobalEnv]].
    1. Perform FunctionInitialize(_F_, ~Normal~, _parameters_, _body_, _scope_).
    1. If _kind_ is `"generator"`, then
      1. Let _prototype_ be ObjectCreate(%GeneratorPrototype%).
      1. Perform DefinePropertyOrThrow(_F_, `"prototype"`, PropertyDescriptor{[[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false*}).
    1. Else if _kind_ is `"normal"`, perform MakeConstructor(_F_).
    1. NOTE: Async functions are not constructable and do not have a [[Construct]] internal method or a `"prototype"` property.
    1. Perform SetFunctionName(_F_, `"anonymous"`).
    1. <ins>Let _prefix_ be the prefix associated with _kind_ in <emu-xref href="#table-dynamic-function-sourcetext-prefixes"></emu-xref>.</ins>
    1. <ins>Let _sourceText_ be the String value whose elements are, in order, the code units of _prefix_, the code units of `" anonymous("`, the code units of _P_, 0x000A (LINE FEED), the code units of `") {"`, 0x000A (LINE FEED), the code units of _bodyText_, 0x000A (LINE FEED), and the code units of `"}"`.</ins>
    1. <ins>Set _F_.[[SourceText]] to _sourceText_.</ins>
    1. Return _F_.
  </emu-alg>
  <emu-note>
    <p>A `prototype` property is automatically created for every function created using CreateDynamicFunction, to provide for the possibility that the function will be used as a constructor.</p>
  </emu-note>

  <emu-table id="table-dynamic-function-sourcetext-prefixes" caption="Dynamic Function SourceText Prefixes">
    <table>
      <tbody>
        <tr class="ins"><th><ins>Kind</ins></th><th><ins>Prefix</ins></th></tr>
        <tr class="ins"><td><ins>`"normal"`</ins></td><td><ins>`"function"`</ins></td></tr>
        <tr class="ins"><td><ins>`"generator"`</ins></td><td><ins>`"function*"`</ins></td></tr>
        <tr class="ins"><td><ins>`"async"`</ins></td><td><ins>`"async function"`</ins></td></tr>
        <tr class="ins"><td><ins>`"async generator"`</ins></td><td><ins>`"async function*"`</ins></td></tr>
      </tbody>
    </table>
  </emu-table>
</emu-clause>


<emu-clause id="proposal-sec-hosthassourcetextavailable">
  <h1>HostHasSourceTextAvailable ( _func_ )</h1>
  <p><ins class="block">HostHasSourceTextAvailable is an implementation-defined abstract operation that allows host environments to prevent the source text from being provided for a given function.</ins></p>
  <p><ins class="block">An implementation of HostHasSourceTextAvailable must complete normally in all cases. This operation must be idempotent. Each time it is called with a specific _func_ as its argument, it must return the same completion record. The default implementation of HostHasSourceTextAvailable is to unconditionally return a normal completion with a value of *true*.</ins></p>
</emu-clause>


<!-- 19.2.3.5 -->
<emu-clause id="proposal-sec-function.prototype.tostring">
  <h1>(<emu-xref href="#sec-function.prototype.tostring">19.2.3.5</emu-xref>) Function.prototype.toString ( )</h1>

  <p>When the `toString` method is called with an object _func_ as its *this* value, the following steps are taken:</p>

  <del class="block">
    <emu-alg>
      1. If _func_ is a Bound Function exotic object, then
        1. Return an implementation-dependent String source code representation of _func_. The representation must conform to the rules below. It is implementation dependent whether the representation includes bound function information or information about the target function.
      1. If Type(_func_) is Object and is either a built-in function object or has an [[ECMAScriptCode]] internal slot, then
        1. Return an implementation-dependent String source code representation of _func_. The representation must conform to the rules below.
      1. Throw a *TypeError* exception.
    </emu-alg>
    <p>`toString` Representation Requirements:</p>
    <ul>
      <li>The string representation must have the syntax of a |FunctionDeclaration|, |FunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |ClassDeclaration|, |ClassExpression|, |ArrowFunction|, |MethodDefinition|, or |GeneratorMethod| depending upon the actual characteristics of the object.
      <li>The use and placement of white space, line terminators, and semicolons within the representation String is implementation-dependent.
      <li>If the object was defined using ECMAScript code and the returned string representation is not in the form of a |MethodDefinition| or |GeneratorMethod| then the representation must be such that if the string is evaluated, using `eval` in a lexical context that is equivalent to the lexical context used to create the original object, it will result in a new functionally equivalent object. In that case the returned source code must not mention freely any variables that were not mentioned freely by the original function's source code, even if these &ldquo;extra&rdquo; names were originally in scope.
      <li>If the implementation cannot produce a source code string that meets these criteria then it must return a string for which `eval` will throw a *SyntaxError* exception.
    </ul>
  </del>

  <ins class="block">
    <emu-alg>
      1. If _func_ is a <emu-xref href="#sec-bound-function-exotic-objects">Bound Function exotic object</emu-xref> or a <emu-xref href="#sec-ecmascript-standard-built-in-objects">built-in Function object</emu-xref>, then return an implementation-dependent String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ is a <emu-xref href="#sec-well-known-intrinsic-objects">Well-known Intrinsic Object</emu-xref> and is not identified as an anonymous function, the portion of the returned String that would be matched by |PropertyName| must be the initial value of the *name* property of _func_.
      1. If _func_ has a [[SourceText]] internal slot and Type(_func_.[[SourceText]]) is String and ! HostHasSourceTextAvailable(_func_) is *true*, then return _func_.[[SourceText]].
      1. If Type(_func_) is Object and IsCallable(_func_) is *true*, then return an implementation-dependent String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.
      1. Throw a *TypeError* exception.
    </emu-alg>

    <emu-grammar>
      NativeFunction :
        `function` PropertyName[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` `[` `native` `code` `]` `}`
    </emu-grammar>
  </ins>
</emu-clause>
